from lets.__module__ import Module, Mount, Container, TestCase
import argparse


class Http(Module):
    """
    Proxy HTTP traffic through the OWASP Zed Attack Proxy (ZAP) and inject the heads-up display (HUD).

    To use:
    1) Generate a certificate authority (CA)
    2) Start ZAP with the CA
    3) Import CA into browser (Chromium works well)
    4) Configure browser to use ZAP as HTTP/HTTPS proxy
    5) Browse with ZAP heads-up-display (HUD)
    """
    images = [
        "owasp/zap2docker-stable:2.9.0",    # amd64 only!
        ]

    @classmethod
    def add_arguments(self, parser):
        parser.add_argument("--interface", type=str, default="0.0.0.0",
            help="interface to listen on")
        parser.add_argument("-p", "--port", type=int, default=8080,
            help="port to listen on")
        parser.add_argument("-c", "--ca", type=argparse.FileType("rb"),
            help="provide certificate authority")
        parser.add_argument("--proxy", type=str, help="use upstream HTTP proxy")

    def handle(self, input, interface="0.0.0.0", port=8080, ca=None, proxy=None):

        with Mount("/data") as mount:

            # Construct command
            cmd  = "zap.sh"
            cmd += " -host %s" % interface
            cmd += " -port %i" % port
            cmd += " -daemon"
            cmd += " -silent"   # Don't reach out for updates
            cmd += " -nostdout" # Limit logging
            cmd += " -configfile /data/zap.conf"

            # Write configuration file
            with mount.open("zap.conf", "w") as f:
                f.write("api.addrs.addr.name=.*\n")
                f.write("api.addrs.addr.regex=true\n")
                f.write("api.disablekey=true\n")
                f.write("hud.enabledForDaemon=true\n")

                # Configure upstream http proxy
                if proxy:
                    if "://" in proxy:
                        [proto,_,proxy] = proxy.partition("://")
                        assert proto.startswith("http"), "Expecting HTTP proxy"
                    proxy_host,_,proxy_port = proxy.partition(":")
                    f.write("connection.proxyChain.enabled=true\n")
                    f.write("connection.proxyChain.hostName=%s\n" % proxy_host)
                    f.write("connection.proxyChain.port=%s\n" % proxy_port)

            # Write certificate authority
            if ca:
                with mount.open("ca.pem", "wb") as f:
                    f.write(ca.read())
                cmd += " -certload /data/ca.pem"

            # Launch proxy
            with Container.run("owasp/zap2docker-stable:2.9.0",
                stdin_open=True, tty=True,
                network="host",
                volumes=mount.volumes,
                command=cmd) as container:

                container.interact()


import platform
if platform.machine() in ["x86_64"]:

    class HttpTestCase(TestCase):
        images = [
            "owasp/zap2docker-stable:2.9.0",    # amd64 only!
            ]

        def test_images(self):
            """
            Test that required images work on the given architecture.
            """
            output = b""
            image = "owasp/zap2docker-stable:2.9.0"
            with Container.run(image, command="./zap.sh -h") as container:
                output = container.output()

            self.assertRegex(output, b"Usage:",
                "Image (%s) failed for architecture: %s" % (image, platform.machine()))
