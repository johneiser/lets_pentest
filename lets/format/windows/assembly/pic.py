from lets.__module__ import Module, Container, Mount, TestCase


# https://github.com/TheWover/donut
class PIC(Module):
    """
    Wrap the supplied Windows .NET assembly as position-independent code (PIC).
    """
    images = [
        "local/donut:1.0.0",    # x86/x64 only!
        ]

    @classmethod
    def add_arguments(cls, parser):
        parser.add_argument("-c", "--class", dest="cls", type=str,
            help="Class to invoke")
        parser.add_argument("-m", "--method", type=str,
            help="Method to invoke")
        parser.add_argument("-p", "--parameter", type=str, action="append",
            help="Parameter(s) to supply invocation")
        parser.add_argument("-a", "--architecture", type=str, choices=["x86", "x64"],
            help="Specify target architecture")
        parser.add_argument("-r", "--runtime", type=str,
            help="Specify CLR runtime version")
        parser.add_argument("-b", "--bypass", action="store_true",
            help="Bypass AMSI/WLDP")
        parser.add_argument("-z", "--compress", action="store_true",
            help="Use compression")
        parser.add_argument("-x", "--exit", type=str, choices=["thread", "process"],
            help="Exit procedure (thread)")

    def handle(self, input, cls=None, method=None, parameter=None, architecture=None, runtime=None, bypass=False, compress=False, exit=None):
        assert input is not None, "Must provide windows .net assembly as input"

        for data in input:

            with Mount("/data") as mount:

                # Write executable input
                with mount.open("input.exe", "wb") as f:
                    f.write(data)

                # Construct command
                cmd  = "./donut"
                if cls: cmd += " -c '%s'" % cls
                if method: cmd += " -m '%s'" % method
                if parameter:
                    if isinstance(parameter, list):
                        parameter = " ".join(parameter)
                    cmd += " -p \"%s\"" % parameter
                
                # Clarify target environment
                if architecture:
                    cmd += " -a %i" % (["x86", "x64"].index(architecture) + 1)
                if runtime:
                    cmd += " -r %s" % runtime
                
                # Clarify behavior
                cmd += " -b %i" % (3 if bypass else 1)
                if compress:
                    cmd += " -z %i" % 2

                # Configure output
                cmd += " -o /data/output.bin -f 1"
                cmd += " /data/input.exe"

                # Launch donut
                with Container.run("local/donut:1.0.0",
                    network_disabled=True,
                    volumes=mount.volumes,
                    command=cmd) as container:

                    for log in container.logs(stream=True, follow=True):
                        self.log.logger.debug(log.strip().decode())

                # Fetch output
                try:
                    with mount.open("output.bin", "rb") as f:
                        yield f.read()
                except FileNotFoundError as e:
                    self.log.error("Processing failed")

import platform
if platform.machine() in ["i386", "i686", "x86_64"]:

    class PICTestCase(TestCase):
        images = [
            "local/donut:1.0.0",    # x86/x64 only!
            ]

        def test_images(self):
            """
            Test that required images work on the given architecture.
            """
            output = b""
            image = "local/donut:1.0.0"
            with Container.run(image, command="./donut -h") as container:
                output = container.output()

            self.assertRegex(output, b"usage:",
                "Image (%s) failed for architecture: %s" % (image, platform.machine()))
