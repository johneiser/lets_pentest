from lets.__module__ import Module, Container, Mount, TestCase


class URL(Module):
    """
    Scan an HTTP resource for SQL injection according to the provided URL.
    """
    images = [
        "local/sqlmap:1.0.0",       # Cross-platform
        ]

    @classmethod
    def add_arguments(cls, parser):
        parser.add_argument("-m", "--method", type=str, help="use specific method")
        parser.add_argument("-d", "--data", type=str, help="use specific data")
        parser.add_argument("-c", "--cookie", type=str, help="use specific cookie value")
        parser.add_argument("-p", "--proxy", type=str, help="use a proxy to connect")
        parser.add_argument("-q", "--quiet", action="store_true", help="limit network activity")
        parser.add_argument("--delay", type=int, help="delay in seconds between each HTTP request")
        parser.add_argument("--timeout", type=int, default=30,
            help="seconds to wait before timeout connection (%(default)i)")
        parser.add_argument("--useragent", type=str, help="use specific useragent")
        parser.add_argument("--default", action="store_true", help="use defaults")
        parser.add_argument("--check-tor", action="store_true",
            help="if proxy is tor, confirm it is working properly")

    def handle(self, input, method=None, data=None, cookie=None, proxy=None, quiet=False, delay=None, timeout=30, useragent=None, default=False, check_tor=False):
        assert input is not None, "Must provide url(s) as input"

        with Mount("/data") as mount:
            
            # Retrieve urls
            for url in input:

                # Write urls to list
                self.log.debug("Loading %i urls", len(url.split()))
                with mount.open("list.txt", "wb") as f:
                    f.write(url)

                # Construct command
                cmd  = "sqlmap"
                cmd += " -m /data/list.txt"     # Supply urls as bulk input file
                cmd += " --timeout %i" % timeout

                if quiet:
                    cmd += " --smart"
                    cmd += " --skip-static"
                    cmd += " --keep-alive"
                    cmd += " --level 1"
                    cmd += " --risk 1"
                else:
                    cmd += " --level 3"
                    cmd += " --risk 2"
            
                if useragent:
                    cmd += " --user-agent '%s'" % useragent
                else:
                    cmd += " --random-agent"

                if default:     cmd += " --batch"
                if method:      cmd += " --method '%s'" % method
                if data:        cmd += " --data '%s'" % data
                if cookie:      cmd += " --cookie '%s'" % cookie
                if proxy:       cmd += " --proxy '%s'" % proxy
                if check_tor:   cmd += " --check-tor"

                # Launch scan
                with Container.run("local/sqlmap:1.0.0",
                    network="host",     # Use host network to allow local addresses
                    volumes=mount.volumes,
                    tty=True,
                    stdin_open=True,
                    command=cmd) as container:

                    container.interact()

class URLTestCase(TestCase):
    images = ["local/sqlmap:1.0.0"]

    def test_images(self):
        """
        Test that required images work on the given architecture.
        """
        import platform
        output = b""
        image = "local/sqlmap:1.0.0"
        with Container.run(image, command="sqlmap -h") as container:
            output = container.output()

        self.assertRegex(output, b"Usage:",
            "Image (%s) failed for architecture: %s" % (image, platform.machine()))
